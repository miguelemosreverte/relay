name: Smart Auto-Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  DOMAIN: 95.217.238.72.nip.io

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
    
    - name: Get deployment info
      id: deploy_info
      run: |
        echo "BUILD_COMMIT=${{ github.sha }}" >> $GITHUB_ENV
        echo "BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV
        echo "BUILD_ACTOR=${{ github.actor }}" >> $GITHUB_ENV
        echo "BUILD_RUN_ID=${{ github.run_id }}" >> $GITHUB_ENV
        echo "BUILD_RUN_URL=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_ENV
        
        # Short commit hash for display
        echo "SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
    
    - name: Setup Go dependencies
      run: |
        go mod download
        go mod verify
    
    - name: Build with deployment info
      run: |
        GOOS=linux GOARCH=arm64 \
        go build \
          -ldflags "-X main.BuildCommit=${{ github.sha }} -X main.BuildTime=${{ env.BUILD_TIME }} -X main.BuildActor=${{ github.actor }}" \
          -o relay-server-arm64 \
          relay-server.go
        
        chmod +x relay-server-arm64
        echo "ðŸ“¦ Binary built: $(du -h relay-server-arm64 | cut -f1)"
        
        # Verify binary exists
        if [ ! -f relay-server-arm64 ]; then
          echo "âŒ Build failed - binary not found!"
          exit 1
        fi
        ls -la relay-server-arm64
    
    - name: Test SCP immediately after build
      run: |
        echo "Testing SCP with small file first..."
        echo "test" > test.txt
        
        mkdir -p ~/.ssh
        echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519
        
        # Test with small file
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          -i ~/.ssh/id_ed25519 \
          test.txt root@95.217.238.72:/tmp/test.txt && echo "âœ… Small file upload works"
        
        # Test with the binary
        echo "Now testing with the actual binary..."
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          -i ~/.ssh/id_ed25519 \
          relay-server-arm64 root@95.217.238.72:/tmp/relay-test.bin && echo "âœ… Binary upload works!" || echo "âŒ Binary upload failed"
    
    - name: Check if deployment is possible
      id: can_deploy
      run: |
        if [ -z "${{ secrets.HETZNER_SSH_KEY }}" ]; then
          echo "âŒ SSH key not configured - skipping deployment"
          echo ""
          echo "ðŸ“ To enable automatic deployment:"
          echo "1. Copy your SSH private key (ed25519)"
          echo "2. Go to Settings â†’ Secrets â†’ Actions"
          echo "3. Add secret named HETZNER_SSH_KEY with the key content"
          echo ""
          echo "SKIP=true" >> $GITHUB_OUTPUT
        else
          echo "âœ… SSH key secret exists - will attempt deployment"
          echo "SKIP=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Setup SSH
      if: steps.can_deploy.outputs.SKIP != 'true'
      run: |
        mkdir -p ~/.ssh
        
        # Write the SSH key (handle both formats)
        echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_ed25519
        chmod 600 ~/.ssh/id_ed25519
        
        # Check if key looks valid
        KEY_SIZE=$(wc -c < ~/.ssh/id_ed25519)
        echo "ðŸ“Š SSH key size: $KEY_SIZE bytes"
        
        if [ "$KEY_SIZE" -lt 100 ]; then
          echo "âŒ SSH key seems too small or missing"
          echo "Please check that HETZNER_SSH_KEY secret contains the full private key"
          exit 1
        fi
        
        # Try to connect with verbose error reporting
        echo "ðŸ”Œ Testing SSH connection..."
        if ssh -v -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
             -o PasswordAuthentication=no -o PubkeyAuthentication=yes \
             -i ~/.ssh/id_ed25519 -o ConnectTimeout=10 \
             root@95.217.238.72 "echo 'Connected successfully'" 2>&1 | tee ssh_test.log; then
          echo "âœ… SSH connection successful!"
        else
          echo "âŒ SSH connection failed. Debug info:"
          echo "Last 20 lines of SSH output:"
          tail -20 ssh_test.log || true
          echo ""
          echo "ðŸ“ Troubleshooting tips:"
          echo "1. Ensure the SSH key is correctly copied to GitHub secrets"
          echo "2. The key should include the full content from -----BEGIN to -----END"
          echo "3. Make sure there are no extra spaces or line breaks"
          exit 1
        fi
    
    - name: Check server status
      id: check
      if: steps.can_deploy.outputs.SKIP != 'true'
      run: |
        echo "ðŸ” Checking server status..."
        
        # Check if server responds to health endpoint
        if curl -f -m 5 https://${{ env.DOMAIN }}/health 2>/dev/null; then
          echo "âœ… Server is healthy"
          echo "MODE=quick" >> $GITHUB_OUTPUT
        else
          echo "âš ï¸ Server not responding, checking SSH..."
          
          # Check if we can SSH
          if ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 -o ConnectTimeout=5 root@95.217.238.72 "echo 'SSH OK'" 2>/dev/null; then
            echo "ðŸ”§ SSH works, will do full setup"
            echo "MODE=full" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Cannot connect via SSH - skipping deployment"
            echo "MODE=skip" >> $GITHUB_OUTPUT
          fi
        fi
    
    # ============ FULL DEPLOYMENT (From Scratch) ============
    - name: Full deployment - Install dependencies
      if: steps.can_deploy.outputs.SKIP != 'true' && steps.check.outputs.MODE == 'full'
      run: |
        echo "ðŸš€ Starting FULL deployment..."
        
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 root@95.217.238.72 "
          set -e
          
          echo 'ðŸ“¦ Installing dependencies...'
          
          # Update system
          apt-get update -qq
          
          # Install Caddy if not present
          if ! command -v caddy &> /dev/null; then
            echo '  Installing Caddy...'
            apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
            apt update -qq
            apt install caddy -y
            systemctl enable caddy
          else
            echo '  âœ“ Caddy already installed'
          fi
          
          # Create directories
          mkdir -p /root/relay
          mkdir -p /etc/caddy
        "
    
    - name: Full deployment - Configure Caddy
      if: steps.can_deploy.outputs.SKIP != 'true' && steps.check.outputs.MODE == 'full'
      run: |
        # Create Caddyfile
        cat > /tmp/Caddyfile << 'EOF'
        ${{ env.DOMAIN }} {
            @websocket {
                header Connection *Upgrade*
                header Upgrade websocket
            }
            
            handle /ws/* {
                reverse_proxy localhost:8080
            }
            
            handle /health {
                reverse_proxy localhost:8080
            }
            
            handle {
                respond "WebSocket Relay Server" 200
            }
            
            # Automatic HTTPS with Let's Encrypt
            tls {
                on_demand
            }
        }
        EOF
        
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 /tmp/Caddyfile root@95.217.238.72:/etc/caddy/Caddyfile
        
        # Reload Caddy
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 root@95.217.238.72 "systemctl reload caddy"
        
        echo "âœ… Caddy configured with automatic SSL"
    
    # ============ DEPLOY BINARY (Both modes) ============
    - name: Deploy binary
      if: steps.can_deploy.outputs.SKIP != 'true' && steps.check.outputs.MODE != 'skip'
      run: |
        echo "ðŸ“¤ Starting deployment..."
        
        # Verify binary exists locally
        if [ ! -f "relay-server-arm64" ]; then
          echo "âŒ Binary not found!"
          ls -la
          exit 1
        fi
        
        echo "âœ… Binary found: $(du -h relay-server-arm64 | cut -f1)"
        
        # Create deployment environment file
        cat > /tmp/relay.env << EOF
        BUILD_COMMIT=${{ github.sha }}
        BUILD_TIME=${{ env.BUILD_TIME }}
        BUILD_ACTOR=${{ github.actor }}
        BUILD_RUN_ID=${{ github.run_id }}
        BUILD_RUN_URL=${{ env.BUILD_RUN_URL }}
        EOF
        
        # Ensure target directory exists on server
        echo "Creating target directory..."
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 \
          root@95.217.238.72 "mkdir -p /root/relay"
        
        # Upload binary (using same command that works in test)
        echo "Uploading binary..."
        scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          -i ~/.ssh/id_ed25519 \
          relay-server-arm64 root@95.217.238.72:/root/relay/relay-server-arm64.new
        
        echo "âœ… Binary uploaded"
        
        # Upload env file using ssh
        echo "Uploading environment file..."
        cat /tmp/relay.env | ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 \
          root@95.217.238.72 "cat > /root/relay/relay.env" || {
            echo "âŒ Failed to upload env file"
            exit 1
        }
        echo "âœ… Environment file uploaded"
        
        echo "ðŸ”„ Deploying..."
        
        ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 \
          root@95.217.238.72 "
          cd /root/relay
          
          # Backup current binary if exists
          if [ -f relay-server-arm64 ]; then
            cp relay-server-arm64 relay-server-arm64.backup
          fi
          
          # Move new binary
          mv relay-server-arm64.new relay-server-arm64
          chmod +x relay-server-arm64
          
          # Stop old server
          pkill -f relay-server-arm64 || true
          
          # Start with deployment info
          source /root/relay/relay.env
          export BUILD_COMMIT BUILD_TIME BUILD_ACTOR BUILD_RUN_ID BUILD_RUN_URL
          
          nohup ./relay-server-arm64 > server.log 2>&1 &
          
          echo 'âœ… Server deployed!'
        "
    
    # ============ VERIFICATION ============
    - name: Verify deployment
      if: steps.can_deploy.outputs.SKIP != 'true' && steps.check.outputs.MODE != 'skip'
      run: |
        echo "â³ Waiting for server to start..."
        
        # Wait up to 30 seconds for server to be ready
        for i in {1..30}; do
          if curl -f -m 2 https://${{ env.DOMAIN }}/health 2>/dev/null; then
            echo "âœ… Server is responding!"
            break
          fi
          echo "  Attempt $i/30..."
          sleep 1
        done
        
        # Final health check with details
        echo ""
        echo "ðŸ“Š Health Check:"
        HEALTH=$(curl -s https://${{ env.DOMAIN }}/health | jq '.')
        echo "$HEALTH"
        
        # Verify deployment info
        COMMIT=$(echo "$HEALTH" | jq -r '.deployment.commit')
        ACTOR=$(echo "$HEALTH" | jq -r '.deployment.actor')
        
        if [ "$COMMIT" = "${{ github.sha }}" ]; then
          echo "âœ… Deployment verified! Commit matches: ${{ steps.deploy_info.outputs.SHORT_SHA }}"
        else
          echo "âŒ Deployment verification failed! Expected ${{ github.sha }}, got $COMMIT"
          
          # Attempt rollback
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_ed25519 root@95.217.238.72 "
            cd /root/relay
            if [ -f relay-server-arm64.backup ]; then
              echo 'ðŸ”„ Rolling back...'
              pkill -f relay-server-arm64 || true
              mv relay-server-arm64.backup relay-server-arm64
              nohup ./relay-server-arm64 > server.log 2>&1 &
            fi
          "
          exit 1
        fi
    
    # ============ TESTING ============
    - name: Run deployment tests
      id: test
      run: |
        echo "ðŸ§ª Running deployment tests..."
        
        # Install Node.js if needed for tests
        if ! command -v node &> /dev/null; then
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
        fi
        
        # Install test dependencies
        cd ${{ github.workspace }}
        npm install ws --no-save
        
        # Run the test suite
        node test/deployment-test.js ${{ env.DOMAIN }} || TEST_RESULT=$?
        
        # Upload test report as artifact
        if [ -f deployment-test-report.md ]; then
          echo "ðŸ“Š Test report generated"
          cat deployment-test-report.md >> $GITHUB_STEP_SUMMARY
        fi
        
        # Store test result
        if [ "${TEST_RESULT:-0}" -eq 0 ]; then
          echo "âœ… All deployment tests passed!"
          echo "TEST_STATUS=passed" >> $GITHUB_OUTPUT
        else
          echo "âš ï¸ Some tests failed, but deployment is complete"
          echo "TEST_STATUS=failed" >> $GITHUB_OUTPUT
        fi
    
    - name: Performance test
      run: |
        echo "âš¡ Running 10-second performance test..."
        
        # Simple performance test using curl
        echo "### Performance Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Test latency
        LATENCIES=""
        for i in {1..10}; do
          START=$(date +%s%N)
          curl -s https://${{ env.DOMAIN }}/health > /dev/null
          END=$(date +%s%N)
          LATENCY=$((($END - $START) / 1000000))
          LATENCIES="$LATENCIES $LATENCY"
        done
        
        # Calculate average
        AVG_LATENCY=$(echo $LATENCIES | awk '{sum=0; for(i=1;i<=NF;i++)sum+=$i; print sum/NF}')
        
        echo "- **Average Latency:** ${AVG_LATENCY}ms" >> $GITHUB_STEP_SUMMARY
        
        # Test WebSocket connection stability
        echo "- **WebSocket:** Testing connection stability..." >> $GITHUB_STEP_SUMMARY
        
        # Create a simple WebSocket test
        cat > /tmp/ws-test.js << 'EOF'
        const WebSocket = require('ws');
        const ws = new WebSocket(`wss://${process.argv[2]}/ws/perf-test`);
        let received = 0;
        
        ws.on('open', () => {
          console.log('Connected');
          // Send 100 messages
          for(let i = 0; i < 100; i++) {
            ws.send(JSON.stringify({test: i, data: 'x'.repeat(1000)}));
          }
          setTimeout(() => {
            ws.close();
            console.log(`Sent 100 messages successfully`);
            process.exit(0);
          }, 5000);
        });
        
        ws.on('error', (e) => {
          console.error('WebSocket error:', e.message);
          process.exit(1);
        });
        EOF
        
        if node /tmp/ws-test.js ${{ env.DOMAIN }}; then
          echo "  âœ… WebSocket stability test passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "  âš ï¸ WebSocket stability test had issues" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
    
    - name: Fetch performance report from API
      run: |
        echo "ðŸ“Š Fetching performance report from server API..."
        
        # Get report in Markdown format
        curl -s -H "Accept: text/markdown" https://${{ env.DOMAIN }}/test/benchmark > performance-report.md
        
        # Get report in HTML format
        curl -s -H "Accept: text/html" https://${{ env.DOMAIN }}/test/benchmark > performance-report.html
        
        # Get report in JSON format
        curl -s https://${{ env.DOMAIN }}/test/benchmark > performance-report.json
        
        # Add commit info to report
        echo "" >> performance-report.md
        echo "---" >> performance-report.md
        echo "**Commit:** ${{ github.sha }}" >> performance-report.md
        echo "**Branch:** ${{ github.ref_name }}" >> performance-report.md
        echo "**Actor:** ${{ github.actor }}" >> performance-report.md
        echo "**Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> performance-report.md
        
        echo "âœ… Reports generated"
    
    - name: Upload performance artifacts
      uses: actions/upload-artifact@v4
      with:
        name: performance-report-${{ github.sha }}
        path: |
          performance-report.md
          performance-report.html
          performance-report.json
          deployment-test-report.md
        retention-days: 90
    
    - name: Create performance badge
      run: |
        # Create a simple status badge JSON
        cat > performance-badge.json << EOF
        {
          "schemaVersion": 1,
          "label": "Performance",
          "message": "âœ… Tests Passed",
          "color": "success",
          "namedLogo": "github-actions"
        }
        EOF
        
        # You can later use this with shields.io or similar service
    
    - name: Checkout gh-pages branch
      uses: actions/checkout@v4
      with:
        ref: gh-pages
        path: gh-pages-existing
      continue-on-error: true
    
    - name: Prepare GitHub Pages content
      run: |
        echo "ðŸ“„ Preparing GitHub Pages content..."
        
        # Create fresh gh-pages directory
        mkdir -p gh-pages/reports
        
        # Copy existing reports if gh-pages branch exists
        if [ -d gh-pages-existing/reports ]; then
          echo "Found existing reports, copying..."
          cp -r gh-pages-existing/reports/* gh-pages/reports/ || true
        fi
        
        # Create reports directory for this commit
        mkdir -p gh-pages/reports/${{ github.sha }}
        
        # Copy performance reports to commit-specific folder
        if [ -f performance-report.html ]; then
          cp performance-report.html gh-pages/reports/${{ github.sha }}/
        fi
        if [ -f performance-report.md ]; then
          cp performance-report.md gh-pages/reports/${{ github.sha }}/
        fi
        if [ -f performance-report.json ]; then
          cp performance-report.json gh-pages/reports/${{ github.sha }}/
        fi
        
        # Extract metrics for index
        THROUGHPUT=$(cat performance-report.json | jq -r '.results.metrics.messages_per_second // 0' 2>/dev/null || echo "0")
        LATENCY=$(cat performance-report.json | jq -r '.results.test_duration_ms // 0' 2>/dev/null || echo "0")
        BANDWIDTH=$(cat performance-report.json | jq -r '.results.metrics.bandwidth_mbps // 0' 2>/dev/null || echo "0")
        TOTAL_MESSAGES=$(cat performance-report.json | jq -r '.results.metrics.total_messages // 0' 2>/dev/null || echo "0")
        TOTAL_BYTES=$(cat performance-report.json | jq -r '.results.metrics.total_bytes // 0' 2>/dev/null || echo "0")
        CONNECTED_USERS=$(cat performance-report.json | jq -r '.results.metrics.connected_users // 0' 2>/dev/null || echo "0")
        
        # Create or update the reports index
        if [ -f gh-pages/reports/index.json ]; then
          # Add new report to existing index
          jq --arg commit "${{ github.sha }}" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --arg actor "${{ github.actor }}" \
             --arg branch "${{ github.ref_name }}" \
             --arg throughput "$THROUGHPUT" \
             --arg latency "$LATENCY" \
             --arg bandwidth "$BANDWIDTH" \
             --arg totalMessages "$TOTAL_MESSAGES" \
             --arg totalBytes "$TOTAL_BYTES" \
             --arg connectedUsers "$CONNECTED_USERS" \
             --arg runNumber "${{ github.run_number }}" \
             --arg runId "${{ github.run_id }}" \
             '.reports = [{
                commit: $commit,
                timestamp: $timestamp,
                actor: $actor,
                branch: $branch,
                throughput: ($throughput | tonumber),
                latency: ($latency | tonumber),
                bandwidth: ($bandwidth | tonumber),
                totalMessages: ($totalMessages | tonumber),
                totalBytes: ($totalBytes | tonumber),
                connectedUsers: ($connectedUsers | tonumber),
                runNumber: ($runNumber | tonumber),
                runId: $runId
              }] + .reports | .reports = .reports[0:50]' \
             gh-pages/reports/index.json > temp.json && mv temp.json gh-pages/reports/index.json
        else
          # Create new index
          cat > gh-pages/reports/index.json << EOF
        {
          "reports": [{
            "commit": "${{ github.sha }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "actor": "${{ github.actor }}",
            "branch": "${{ github.ref_name }}",
            "throughput": $THROUGHPUT,
            "latency": $LATENCY,
            "bandwidth": $BANDWIDTH,
            "totalMessages": $TOTAL_MESSAGES,
            "totalBytes": $TOTAL_BYTES,
            "connectedUsers": $CONNECTED_USERS,
            "runNumber": ${{ github.run_number }},
            "runId": "${{ github.run_id }}"
          }]
        }
        EOF
        fi
        
        # Copy dashboard files
        cp -r docs/* gh-pages/ 2>/dev/null || true
        
        echo "âœ… GitHub Pages content prepared"
    
    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./gh-pages
        keep_files: true
        commit_message: "ðŸ“Š Update performance reports for ${{ github.sha }}"
    
    - name: Summary
      run: |
        echo "## ðŸŽ‰ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Deployment Info" >> $GITHUB_STEP_SUMMARY
        echo "- **Mode:** ${{ steps.check.outputs.MODE == 'full' && 'Full Setup' || 'Quick Update' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** \`${{ steps.deploy_info.outputs.SHORT_SHA }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Actor:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Time:** ${{ env.BUILD_TIME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Test Status:** ${{ steps.test.outputs.TEST_STATUS == 'passed' && 'âœ… Passed' || 'âš ï¸ Some tests failed' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Endpoints" >> $GITHUB_STEP_SUMMARY
        echo "- **WebSocket:** \`wss://${{ env.DOMAIN }}/ws/{username}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Health:** https://${{ env.DOMAIN }}/health" >> $GITHUB_STEP_SUMMARY
        echo "- **Performance Dashboard:** https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Quick Test Commands" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
        echo "# Check health" >> $GITHUB_STEP_SUMMARY
        echo "curl https://${{ env.DOMAIN }}/health | jq '.deployment'" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "# Test WebSocket" >> $GITHUB_STEP_SUMMARY
        echo "wscat -c wss://${{ env.DOMAIN }}/ws/test-user" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY